#' Simulation of observations from the model
#'
#' @param N (integer) to tal number of partitions
#' @param lambda (numeric) average number of sequences per partition
#' @param propl (numeric vector) proportion of each possible sequence type in the order automatically generated by the defseqtypes function
#' @param pobs (numeric vector) amplification probability of each target
#'
#' @return a vector containing the number of observation for each observation type ($NY)
#' along with those observation types ($ObsTypes) in terms of targets coverage
#'
#' @export
SimulObs=function(N,lambda,propl,pobs){
  J=length(pobs)
  L=sum(1:J) # number of possible different contiguous sequences
  lambdal=lambda*propl

  # sequences types:
  L=sum(1:J) # number of possible different contiguous sequences
  coverseq=defseqtypes(J) # description of the sequences types

  # number of sequence of each type in each cell:
  # the three following versions seem to give the same result
  Kil=matrix(data=NA,ncol=L,nrow=N)
  for(l in 1:L){
    Kil[,l]=rpois(N,lambdal[l])
  }
  Ki=apply(Kil,1,sum)
  # hist(Ki)
  # hist(rpois(N,lambdaT))

  # number of each target in each cell:
  Kij=Kil%*%coverseq
  # table(Kij)

  # partitions with detected presence of each target:
  Yij=matrix(data=NA,ncol=J,nrow=N)
  for(j in 1:J){
    Yij[,j]=rbinom(N,Kij[,j],pobs[j])
  }
  apply(Yij,2,table)
  Yij=(Yij>0)*1
  apply(Yij,2,table)
  Yobs=apply(Yij,1,paste0,collapse="-") # = what is observed (presence / absence of
  # each target in each partition)
  # can we recover pobsT and lambda from this last data type?

  # Possible values of the target vector:
  ObsTypesChar=sort(unique(Yobs))
  NY=table(Yobs)
  A=length(ObsTypesChar) # number of possible values of the target vector
  ObsTypes=matrix(data=NA, ncol=J,nrow=A)
  for(a in 1:A){
    ObsTypes[a,]=Yij[which(Yobs==ObsTypesChar[a])[1],]
  }
  rownames(ObsTypes)=ObsTypesChar
  # ObsTypes

  NY=table(Yobs)

  return(list(NY=NY,coverseq=coverseq,ObsTypes=ObsTypes))
}

#' Possible sequence types for a specified number of targets
#'
#' @param J (integer), number of targets.
#'
#' @return a matrix containing, in row, the possible sequence types and in columns which target is covered by each sequence type
#' @export
defseqtypes=function(J){
  # sequences types:
  L=sum(1:J) # number of possible different contiguous sequences
  coverseq=matrix(data=0,ncol=J,nrow=L) # description of the sequences types
  j=0
  for(k in J:1){
    for(i in k:J){
      j=j+1
      coverseq[j,]=c(rep(0,(i-k)),rep(1,k),rep(0,J-i))
    }
  }
  return(coverseq)
}


#' Probability of each observation given each possible latent scheme
#'
#' @param LatTypesj (numeric matrix) number of sequence containing each target in each latent type of LatTypes library.
#' @param ObsTypes (binary matrix) contains, for each observation type (in row), if each target is present (1) of absent (0).
#' @param wobs (vector) non-amplification probability for each target
#'
#' @return a matrix containing the probability of each observation given each possible latent scheme.
#' @noRd
PKAcompute=function(LatTypesj,ObsTypes,wobs){
  A=nrow(ObsTypes)
  M=nrow(LatTypesj)
  PKA=matrix(data=NA,ncol=A,nrow=M)
  # colnames(PKA)=ObsTypesChar
  # rownames(PKA)=LatTypesChar
  for(m in 1:M){
    for(a in 1:A){
      kmj=LatTypesj[m,]
      ya=ObsTypes[a,]
      # lPKA[m,a]=sum((1-ya)*kmj*log(wobs)+ya*log(1-wobs^kmj))
      PKA[m,a]=prod((1-ya)*(wobs^kmj)+ya*(1-(wobs^kmj)))
    }
  }
  return(PKA)
}



#' A priori probability of each possible latent scheme
#'
#' @param LatTypes (matrix) contains all the possibilities for the number of each sequence type inside a partition.
#' @param lambdal (numeric vector) average number of sequences of each type in one partition of ddPCR.
#'
#' @return a matrix containing the a priori probability of each possible latent scheme.
#' @noRd
PKcompute=function(LatTypes,lambdal){
  L=length(lambdal)
  PK=dpois(x=LatTypes[,1],lambda=lambdal[1])
  for(l in 2:L){
    PK=PK*dpois(x=LatTypes[,l],lambda=lambdal[l])
  }
  return(PK)
}
